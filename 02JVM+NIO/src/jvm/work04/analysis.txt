串行GC：serial GC  -XX:+UseSerialGC
新生代采用标记复制算法，老年代采用标记清除整理算法。
使用单个线程对垃圾进行回收，全阶段都会STW。
不适用于多核计算机，因为无法发挥多核的优势，效率低时间长，增加堆内存单次GC时间增加，GC时间不稳定。
不会采用此GC策略。
默认最大年轻代大小为堆内存的1/3
重要参数：
-XX:+USeParNewGC 改进版本的 Serial GC，可以配合 CMS 使用

并行GC：-XX:+UseParallelGC  JDK 6 7 8 默认GC策略
新生代采用标记复制算法，老年代采用标记清除整理算法。
使用多个线程对垃圾进行回收，-XX:ParallelGCThreads=N，指定线程数，默认是CPU核数，全阶段都会STW。
适用于多核服务器，吞吐量很高，增加堆内存单次GC时间增加，GC时间不稳定。
对吞吐量要求高的场景下可以使用此GC策略
默认最大年轻代大小为堆内存的1/3
重要参数：
-XX:ParallelGCThreads=N 来指定 GC 线程数， 其默认值为 CPU 核心数


CMS GC：-XX:+UseConcMarkSweepGC
新生代采用标记复制算法(STW)，老年代采用并行标记清除算法（大部分阶段不进行STW），但是老年代因为没有压缩整理会有碎片问题，在内存较大的情况下可能会存在GC暂停时间不可预测的问题
默认情况下使用的并发线程数等于CPU核心数的1/4。
适用于多核服务器，延迟较低，GC时间较为可控
对延迟要求较高的场景下可以使用此GC策略 一般为 ParNew+CMS组合
默认最大年轻代大小为：64M*GC线程数*13/10
重要参数：

G1 GC：-XX:+UseG1GC JDK 9 10 11 12 13 14 15 16 17 18 默认GC策略
将堆内存分为多个(通常是2048)个小块，哪一块垃圾多就优先清理哪一块，其目的就是将STW停顿的时间和分布，变成可预期且可配置的
每次暂停回收所有年轻代的小块，和部分老年代的小块。回收年轻代STW(标记复制)，回收老年代采用的是与CMS基本一致的并发标记
默认情况下使用的线程数等于CPU核心数的1/4。-XX:ConcGCThreads
适用于内存较大(4G以上)的多核服务器，延迟较低，平均GC时间可控
对延迟要求较高且使用内存较大的场景下可以使用此GC策略
默认最大年轻代大小为：60%  默认初始年轻代大小为5%
注意事项：千万要避免G1 GC的退化 可能原因：1.并发模式失败,往老年代放垃圾的速度太快了 2.晋升失败，老年代空间不够 3.巨型对象分配失败
重要参数：
-XX:MaxGCPauseMillis=50 GC暂停时间尽量控制在50ms以下
-XX:G1NewSizePercent:初始年轻代占整个 Java Heap 的大小，默认值为 5%
-XX:G1MaxNewSizePercent:最大年轻代占整个 Java Heap 的大小，默认值为 60%
-XX:G1HeapRegionSize:设置每个 Region 的大小，单位 MB，需要为 1、2、4、8、16、32 中的某个值，默认是堆内存的 1/2000。如果这个值设置比较大，那么大对象就可以进入 Region 了
-XX:ConcGCThreads:与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1/4，减少这个参数的数值可能会提升并行回收 的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长
-XX:+InitiatingHeapOccupancyPercent(简称 IHOP):G1 内部并行回收循环启动的阈值，默认为 Java Heap的 45%。这个可 以理解为老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收。这个值非常重要，它决定了在什么时间启动老年代的并行回收
-XX:G1HeapWastePercent:G1停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中的对象，但是如果 下降到了 5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以遗留少量的下次处理，这样也降低了 单次消耗的时间
-XX:+GCTimeRatio:这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9，跟新生代内存的分配比例一 致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100/(1+GCTimeRatio)。这样如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面。Parallel GC 的默认值是 99，表示 1% 的时间被用在 GC 上面，这是因为 Parallel GC 贯 穿整个 GC，而 G1 则根据 Region 来进行划分，不需要全局性扫描整个内存堆



ZGC: XX:+UnlockExperimentalVMOptions -XX:+UseZGC   JDK11引入linux
GC暂定时间极短 3-5ms，支持超大内存（T级别），但是吞吐量对比G1 GC有15%的下降，几乎全部并发
适用于延迟要很高，内存极大，吞吐量不是很高的场景

ShenandoahGC：XX:+UnlockExperimentalVMOptions - XX:+UseShenandoahGC JDK11引入linux
young gc 也可以实现并发处理，与ZGC类似
适用于延迟要很高，内存使用极大，吞吐量不是很高的场景 （量化交易）









./wrk  -c 40 -d30s http://localhost:8088



